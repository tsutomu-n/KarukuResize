# プロジェクト現状: 現役コードのアーキテクチャ

## 1. 前提
- 本ドキュメントは現役コードのみを対象とする。
- 対象外:
  - `archive/`
  - `src/karuku_resizer/gui_app_backup.py`
  - `tests/legacy/`

## 2. 主要コンポーネント

### 2.1 エントリポイント
1. GUI:
   - `karukuresize-gui = karuku_resizer.gui_app:main`
2. CLI:
   - `karukuresize-cli = karuku_resizer.resize_core:main`
3. EXEビルド:
   - `karukuresize-build-exe = karuku_resizer.build_exe:main`

定義場所: `pyproject.toml`

### 2.2 GUI層
- ファイル: `src/karuku_resizer/gui_app.py`
- 主責務:
  1. 画面構築（入力、プレビュー、保存操作）
  2. 設定の読み込み/保存
  3. ユーザー入力の妥当化（最低限）
  4. 保存パイプライン呼び出し
  5. 実行結果表示（EXIF反映状態を含む）

### 2.3 保存パイプライン層
- ファイル: `src/karuku_resizer/image_save_pipeline.py`
- 主責務:
  1. 出力形式解決 (`resolve_output_format`)
  2. 品質正規化 (`normalize_quality`)
  3. 保存オプション生成 (`_build_save_kwargs`)
  4. EXIF組み立て (`_build_exif_bytes`)
  5. 実保存 + EXIF失敗時フォールバック (`save_image`)

### 2.4 CLI層
- ファイル: `src/karuku_resizer/resize_core.py`
- 主責務:
  1. 引数パース
  2. ファイル探索と反復処理
  3. リサイズ/圧縮実行
  4. ログ出力と終了コード管理

### 2.5 テスト層（現行）
- `tests/test_image_save_pipeline.py`
  - 保存形式、品質丸め、EXIF keep/edit/remove、dry-run の検証。
- `tests/test_basic.py`
  - 最小サンプルテスト。

## 3. データフロー（GUI保存時）

1. GUI入力:
   - モード（比率/幅/高さ/固定）
   - 出力形式
   - 品質
   - EXIFモード
   - GPS削除
   - ドライラン
   - 詳細ログ
2. `gui_app.py`:
   - `_build_save_options()` で `SaveOptions` を生成。
3. `image_save_pipeline.py`:
   - `save_image()` が画像保存とメタデータ処理を実行。
4. GUIへ返却:
   - `SaveResult` に基づきメッセージ表示。

## 4. 設定管理の現状
- `gui_app.py` 内 `SettingsManager` が `karuku_settings.json` を管理。
- 保存対象:
  - リサイズ入力値
  - 出力形式
  - 品質
  - EXIFモード/GPS削除
  - ドライラン/詳細ログ
  - 詳細設定展開状態
  - ウィンドウサイズ、最後の入出力ディレクトリ

## 5. 現行アーキテクチャの強み
1. GUI層と保存ロジックが分離されている（機能追加の影響範囲が比較的限定される）。
2. `SaveResult` が状態を十分保持しており、UI表示に再利用しやすい。
3. フォーマット対応可否は `supported_output_formats()` で実行時判定可能。

## 6. 現行アーキテクチャの技術的論点
1. `ExifEditValues` が4項目固定で、拡張時に分岐追加が増える。
2. GUIの設定項目増加時、1行横並びUIは可読性が下がりやすい。
3. ドキュメント記述と現行GUIの実装状態に差分があるため、運用時はコード基準が必要。

## 7. 今回計画で守る設計原則
1. 保存パイプライン中心で拡張し、GUIに保存ロジックを持ち込まない。
2. 互換性維持（既存設定キーを壊さない）。
3. 段階実装（簡易導線を壊さず、プロ導線を追加）。
4. テスト先行で回帰リスクを抑える。
